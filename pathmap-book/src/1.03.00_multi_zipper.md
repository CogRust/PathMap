# Creating Multiple Zippers in the Same Map
Sometimes you need a write-enabled zipper along side one or more other zippers in the same map.  This primarily happens if you want to:

* Use an algebraic operation to write results into the same map that also holds the arguments
* Use zippers to parallelize work over multiple threads

Creating multiple zippers in the same map is possible and very handy.  That's what the [`ZipperHead`] object is designed to enable.

## Making Multiple Zippers
The normal [`PathMap`] methods to create write-enabled zippers, ie. [`write_zipper`](PathMap::write_zipper) and [`write_zipper_at_path`](PathMap::write_zipper_at_path) require an `&mut` borrow of the map.  This prevents a write-enabled zipper from being created while any other zipper simultaneously exists in that map (for reading or writing).  This can be very obnoxious, especially when you are working within a single large map.

[`ZipperHead`] provides an alternative API to create zippers, that allows the exclusivity rules to be checked at runtime, rather than statically by the compiler.

### Example: Creating Multiple Zippers in a PathMap

```rust
use pathmap::PathMap;

// Create and populate a map
let mut map = PathMap::new();
map.set_val_at(b"data:0000:value", 100);
map.set_val_at(b"data:0001:value", 200);

// Create a ZipperHead at the map root
let zh = map.zipper_head();

// Now we can create multiple write zippers at different exclusive paths
let mut reader_0 = zh.read_zipper_at_path(b"data:0000:value").unwrap();
let mut reader_1 = zh.read_zipper_at_path(b"data:0001:value").unwrap();
let mut writer_0 = zh.write_zipper_at_exclusive_path(b"data:0000:result").unwrap();
let mut writer_1 = zh.write_zipper_at_exclusive_path(b"data:0001:result").unwrap();

// Each zipper can now independently modify its exclusive region
writer_0.set_val(*reader_0.val().unwrap() * 2);
writer_1.set_val(*reader_1.val().unwrap() * 2);

// Clean up - zippers must be dropped before the ZipperHead
drop(writer_0);
drop(writer_1);
drop(reader_0);
drop(reader_1);
drop(zh);

// Verify the results
assert_eq!(map.get_val_at(b"data:0000:result"), Some(&200));
assert_eq!(map.get_val_at(b"data:0001:result"), Some(&400));
```

NOTE: Using [`ZipperHead`] methods comes with a high runtime cost relative to using the [`PathMap`] methods.  So don't use a `ZipperHead` unless you need to.

## Zipper Exclusivity Rules


A zipper is a cursor to read and/or write into a location in a trie.  By extension it is also a permission to perform that reading / writing.  

GOAT more to say in this section

## Multi-threading Patterns

Many zipper types implement [`Send`] and/or [`Sync`] meaning multiple threads may be accessing the same underlying trie.

GOAT move to a new section