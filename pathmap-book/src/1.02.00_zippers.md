# A Zipper is a Cursor in a trie / space
Zippers are persistent pointers that refer to a location within a trie, called the zipper's `focus`.  When an operation is applied through a zipper, it accesses and /or acts on the focus.  The advantage of zippers is that they don't require re-traversal of the in-memory data structure for each operation.

A zipper is most often used to point to a location within a [PathMap], however a zipper may also operate within other kinds of spaces.  One example is the [ACT] on-disk file format, which allows a space to be explored without requiring the entire data structure to be loaded into memory.  Another example is a virtualized space, such as an infinite space that is defined parametrically.

## Zipper Traits
Zipper capabilities are defined across a number of traits.  There are many different zipper objects depending on the function of the zipper and the underlying data structure it accesses.  Therefore it makes sense to treat zippers as generic types with the feature-specific trait bounds you require.

| Trait            | Purpose / Description                                                                  |
|------------------|----------------------------------------------------------------------------------------|
| [`Zipper`](./1.02.01_zipper_trait.md)         | Inspect the trie structure           |
| [`ZipperConcrete`](./1.02.01_zipper_trait.md#zipperconcrete)   | Inspect structural sharing  |
| [`ZipperSubtries`](./1.02.01_zipper_trait.md#zippersubtries)   | Make a map from a subtrie, or to provide an operand to an algebraic op |
| [`ZipperReadOnlySubtries`](./1.02.01_zipper_trait.md#zipperreadonlysubtries)   | Create [`TrieRef`] objects  |
| [`ZipperForking`](./1.02.01_zipper_trait.md#zipperforking)   | Create temporary zippers |
| [`ZipperValues`](./1.02.02_zipper_values.md#zippervalues)   | Access values    |
| [`ZipperReadOnlyValues`](./1.02.02_zipper_values.md#zipperreadonlyvalues)   | Access values with extended lifetime  |
| [`ZipperReadOnlyConditionalValues`](./1.02.02_zipper_values.md#zipperreadonlyconditionalvalues)   | Access values with `witness` pattern  |
| [`ZipperAbsolutePath`](./1.02.03_zipper_paths.md#zipperabsolutepath)   | Get more complete path information  |
| [`ZipperPathBuffer`](./1.02.03_zipper_paths.md#zipperpathbuffer)   | Control zipper's internal buffer allocation  |
| [`ZipperMoving`](./1.02.04_zipper_moving.md)   | Moves the zipper's focus within the trie |
| [`ZipperIteration`](./1.02.05_zipper_iter.md#zipperiteration)   | Traverse / exploration the trie |
| [`ZipperReadOnlyIteration`](./1.02.05_zipper_iter.md#zipperreadonlyiteration)   | Iterate and borrow values in the trie  |
| [`ZipperReadOnlyConditionalIteration`](./1.02.05_zipper_iter.md#zipperreadonlyconditionaliteration)   | Iterate trie values with `witness` pattern  |
| [`ZipperWriting`](./1.02.06_zipper_writing.md)   | Modify the trie structure and values, and perform algebraic ops  |

## Zipper Objects
The `pathmap` crate provides a number of zipper objects, and it is also permissible to implement most (but not all) of the zipper traits on outside objects.  Therefore this is not a complete set of zippers.



GOAT, make a diagram / table with all the zipper-like API objects.  Show where each one fits based on criteria of: *Writeable, *Movable, *Cost-to-Create, *'static Lifetime, etc.

PathMap: 'static lifetime, Writeable, NOT Movable, medium-cost to create
TrieRef: borrowed lifetime, NOT Writeable, NOT Movable, ultra low cost to create
ReadZipperOwned: 'static lifetime, NOT Writeable, Movable, high cost to create
ReadZipper: borrowed lifetime, NOT Writeable, Movable, low cost to create
WriteZipperOwned: 'static lifetime, Writeable, Movable, high cost to create
WriteZipper: borrowed lifetime, Writeable, Movable, low cost to create

