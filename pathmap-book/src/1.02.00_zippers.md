# A Zipper is a Cursor in a trie / space

Zippers are persistent pointers that refer to a location within a trie, called the zipper's `focus`.  When an operation is applied through a zipper, it accesses and /or acts on the focus.  The advantage of zippers is that they don't require re-traversal of the in-memory data structure for each operation.

A zipper is most often used to point to a location within a [PathMap], however a zipper may also operate within other kinds of spaces.  One example is the [ACT] on-disk file format, which allows a space to be explored without requiring the entire data structure to be loaded into memory.  Another example is a virtualized space, such as an infinite space that is defined parametrically.

## Zipper Traits

Zipper capabilities are defined across a number of traits.  There are many different zipper objects depending on the function of the zipper and the underlying data structure it accesses.  Therefore it makes sense to treat zippers as generic types with the feature-specific trait bounds you require.

| Trait            | Purpose / Description                                                                  |
|------------------|----------------------------------------------------------------------------------------|
| [`Zipper`]         | Provides methods to inspect the trie structure at the focus. Implemented on all zipper types.           |
| [`ZipperValues`]   | Provides the [`val`] method to access the value at the focus.  Implemented on zippers capable of accessing values in the trie.    |
| [`ZipperMoving`]   | Provides methods to move the zipper's focus within the trie. Implemented on zippers capable of relative movement.  |
| [`ZipperIteration`]   | Provides methods to traverse the zipper in a depth-first pattern, stepping by single path bytes, jumping to the next value position, or iterating child paths at a relative depth. Implemented on zippers capable of relative movement. |
| [`ZipperConcrete`]   | Provides the [`is_shared`] method to determine structural sharing at the focus.  Implemented on zippers that access in-memory (non-virtual) data structures.  |
| [`ZipperSubtries`]   | Provides the [`make_map`] method to create a new [`PathMap`] from the entire sub-space starting at the zipper's focus.  Implemented on zippers that operate within `PathMap`s. |
| [`ZipperForking`]   | Provides the [`fork_read_zipper`] method to create a new temporary zipper that implements `ZipperAbsolutePath + ZipperIteration + ZipperValues`. |
| [`ZipperReadOnlyValues`]   | GOAT  |
| [`ZipperReadOnlyConditionalValues`]   | GOAT  |
| [`ZipperReadOnlyIteration`]   | GOAT  |
| [`ZipperReadOnlyConditionalIteration`]   | GOAT  |
| [`ZipperReadOnlySubtries`]   | GOAT  |
| [`ZipperAbsolutePath`]   | GOAT  |
| [`ZipperPathBuffer`]   | GOAT  |





Some zippers permit relative movement and it is almost always faster to move a zipper than to create a one.  For zippers implementing [ZipperMoving], the focus may be moved to a longer path (called `descending`) or to a shorter path (called `ascending`) subject to limits covered in greater detail later in this chapter.

# Basic Zipper Movement

GOAT, consider merging the stepping vs. jumping section here


The zipper's focus may be accessed by calling [Zipper::path].

# Read-only Zippers vs WriteZippers

GOAT, To write.


GOAT, make a diagram / table with all the zipper-like API objects.  Show where each one fits based on criteria of: *Writeable, *Movable, *Cost-to-Create, *'static Lifetime, etc.

PathMap: 'static lifetime, Writeable, NOT Movable, medium-cost to create
TrieRef: borrowed lifetime, NOT Writeable, NOT Movable, ultra low cost to create
ReadZipperOwned: 'static lifetime, NOT Writeable, Movable, high cost to create
ReadZipper: borrowed lifetime, NOT Writeable, Movable, low cost to create
WriteZipperOwned: 'static lifetime, Writeable, Movable, high cost to create
WriteZipper: borrowed lifetime, Writeable, Movable, low cost to create

